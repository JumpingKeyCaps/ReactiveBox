// ------------------- DYNAMIC UNIFORMS (Contrôlés par Kotlin) -------------------
uniform float2 resolution;
uniform float2 uTilt; // Capteur (maintenant calibré dans Kotlin)
uniform float uTime;  // Animation

// Géométrie
uniform float uBoxHalfSize;   //  Profondeur de la boîte

// Réglages d'Apparence
uniform float uEdgeThickness; // Épaisseur de la ligne néon
uniform float uRimIntensity;  // Luminosité du halo néon
uniform float uSpecularPower; // Puissance de la réflexion (non utilisé, conservé)
uniform float uNoiseStrength; // Force du bruit (non utilisé, conservé)
uniform float uFaceBrightness; // Luminosité globale des faces (FACE_BRIGHTNESS)

// Couleurs Néon et Highlight
uniform half3 uNeonLineColor;
uniform half3 uHighlightColor;

// Couleurs des faces (Contrôlées par Kotlin)
uniform half3 uColorBox;
uniform half3 uColorTopLight;
uniform half3 uColorTopDark;
uniform half3 uColorBottomLight;
uniform half3 uColorBottomDark;
uniform half3 uColorLeftLight;
uniform half3 uColorLeftDark;
uniform half3 uColorRightLight;
uniform half3 uColorRightDark;

// Ambient Occlusion
uniform float uAOStrength;     // Intensité de l'AO (AO_STRENGTH)
uniform float uAORadius;       // Rayon d'influence de l'AO (AO_RADIUS)


// ------------------- STATICS (Constantes AGSL) -------------------
const float WALL_LIMIT = 1.0;


// ----------------- HELPERS -----------------
float2 aspectCorrect(float2 uv) {
    uv.x *= resolution.x / resolution.y;
    return uv;
}

float2 normalizeTilt(float2 tilt) {
    // Utilise uBoxHalfSize
    float maxOffset = WALL_LIMIT - uBoxHalfSize;
    return clamp(tilt, -maxOffset, maxOffset);
}

// distance to segment (unsigned)
float sdSegment(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float denom = dot(ba, ba);
    if (denom <= 1e-8) return length(pa);
    float h = clamp(dot(pa, ba) / denom, 0.0, 1.0);
    return length(pa - ba * h);
}

// Signed distance to convex quad (negative inside)
float sdQuadSigned(float2 p, float2 a, float2 b, float2 c, float2 d) {
    float d0 = sdSegment(p, a, b);
    float d1 = sdSegment(p, b, c);
    float d2 = sdSegment(p, c, d);
    float d3 = sdSegment(p, d, a);
    float mind = min(min(d0, d1), min(d2, d3));

    float2 ab = b - a;
    float2 bc = c - b;
    float2 cd = d - c;
    float2 da = a - d;

    float c0 = ab.x * (p.y - a.y) - ab.y * (p.x - a.x);
    float c1 = bc.x * (p.y - b.y) - bc.y * (p.x - b.x);
    float c2 = cd.x * (p.y - c.y) - cd.y * (p.x - c.x);
    float c3 = da.x * (p.y - d.y) - da.y * (p.x - d.x);

    bool allPos = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0);
    bool allNeg = (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);

    return (allPos || allNeg) ? -mind : mind;
}

// Signed area (shoelace) of quad (a,b,c,d). Positive => CCW
float quadSignedArea(float2 a, float2 b, float2 c, float2 d) {
    float s = 0.0;
    s += a.x * b.y - b.x * a.y;
    s += b.x * c.y - c.x * b.y;
    s += c.x * d.y - d.x * c.y;
    s += d.x * a.y - a.x * d.y;
    return 0.5 * s;
}

// swap helper
void swap(inout float2 x, inout float2 y) {
    float2 t = x; x = y; y = t;
}

// Calcul de l'Ambient Occlusion basé sur la distance aux arêtes (avec diagonales)
float calculateAO(float2 p, int faceId,
                  float2 boxTL, float2 boxTR, float2 boxBR, float2 boxBL,
                  float2 outerTL, float2 outerTR, float2 outerBR, float2 outerBL) {

    float ao = 1.0; // Pas d'occlusion par défaut
    float boxHalfSize = uBoxHalfSize; // Utilise l'uniforme

    // Utilise le nouvel uniforme uAORadius
    float aoRadius = uAORadius;

    if (faceId == 0) {
        // FOND : AO aux 4 bords
        float distToEdges = min(
            min(abs(p.x - boxHalfSize), abs(p.x + boxHalfSize)),
            min(abs(p.y - boxHalfSize), abs(p.y + boxHalfSize))
        );
        ao = smoothstep(0.0, aoRadius, distToEdges);

    } else if (faceId == 1) {
        // TOP WALL : AO le long de l'arête intérieure + diagonales
        float distToBottom = abs(p.y - boxHalfSize);
        ao = smoothstep(0.0, aoRadius, distToBottom);

        // AO le long des diagonales gauche et droite
        float distToDiagL = sdSegment(p, boxTL, outerTL);
        float distToDiagR = sdSegment(p, boxTR, outerTR);
        float diagAO = smoothstep(0.0, aoRadius * 0.6, min(distToDiagL, distToDiagR));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 2) {
        // BOTTOM WALL : AO le long de l'arête intérieure + diagonales
        float distToTop = abs(p.y + boxHalfSize);
        ao = smoothstep(0.0, aoRadius, distToTop);

        // AO le long des diagonales
        float distToDiagL = sdSegment(p, boxBL, outerBL);
        float distToDiagR = sdSegment(p, boxBR, outerBR);
        float diagAO = smoothstep(0.0, aoRadius * 0.6, min(distToDiagL, distToDiagR));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 3) {
        // LEFT WALL : AO le long de l'arête intérieure + diagonales
        float distToRight = abs(p.x + boxHalfSize);
        ao = smoothstep(0.0, aoRadius, distToRight);

        // AO le long des diagonales haut et bas
        float distToDiagT = sdSegment(p, boxTL, outerTL);
        float distToDiagB = sdSegment(p, boxBL, outerBL);
        float diagAO = smoothstep(0.0, aoRadius * 0.6, min(distToDiagT, distToDiagB));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 4) {
        // RIGHT WALL : AO le long de l'arête intérieure + diagonales
        float distToLeft = abs(p.x - boxHalfSize);
        ao = smoothstep(0.0, aoRadius, distToLeft);

        // AO le long des diagonales haut et bas
        float distToDiagT = sdSegment(p, boxTR, outerTR);
        float distToDiagB = sdSegment(p, boxBR, outerBR);
        float diagAO = smoothstep(0.0, aoRadius * 0.6, min(distToDiagT, distToDiagB));
        ao *= mix(0.4, 1.0, diagAO);
    }

    // Mix avec la force de l'AO (Utilise le nouvel uniforme uAOStrength)
    return mix(1.0, ao, uAOStrength);
}

// ----------------- MAIN -----------------
half4 main(float2 fragCoord) {
    // 1. uv / view space
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;
    uv.y *= -1.0;

    float2 nTilt = normalizeTilt(uTilt);
    float2 p_view = aspectCorrect(uv + nTilt);

    // outer corners (aspect corrected then tilt offset)
    float2 nTilt_corrected = aspectCorrect(nTilt);
    float2 outerTL = aspectCorrect(float2(-WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerTR = aspectCorrect(float2( WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerBR = aspectCorrect(float2( WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;
    float2 outerBL = aspectCorrect(float2(-WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;

    // box corners (center) - UTILISE uBoxHalfSize
    float2 boxTL = float2(-uBoxHalfSize,  uBoxHalfSize);
    float2 boxTR = float2( uBoxHalfSize,  uBoxHalfSize);
    float2 boxBR = float2( uBoxHalfSize, -uBoxHalfSize);
    float2 boxBL = float2(-uBoxHalfSize, -uBoxHalfSize);

    // --- build quads with consistent winding (CCW) ---
    float2 a0 = boxTL, b0 = boxTR, c0 = boxBR, d0 = boxBL;
    if (quadSignedArea(a0,b0,c0,d0) < 0.0) { swap(b0, d0); }

    float2 a1 = boxTL, b1 = boxTR, c1 = outerTR, d1 = outerTL;
    if (quadSignedArea(a1,b1,c1,d1) < 0.0) { swap(b1, d1); }

    float2 a2 = boxBR, b2 = boxBL, c2 = outerBL, d2 = outerBR;
    if (quadSignedArea(a2,b2,c2,d2) < 0.0) { swap(b2, d2); }

    float2 a3 = outerTL, b3 = boxTL, c3 = boxBL, d3 = outerBL;
    if (quadSignedArea(a3,b3,c3,d3) < 0.0) { swap(b3, d3); }

    float2 a4 = boxTR, b4 = outerTR, c4 = outerBR, d4 = boxBR;
    if (quadSignedArea(a4,b4,c4,d4) < 0.0) { swap(b4, d4); }

    // 2. signed distances
    float sd_box = sdQuadSigned(p_view, a0,b0,c0,d0);
    float sd_top = sdQuadSigned(p_view, a1,b1,c1,d1);
    float sd_bottom = sdQuadSigned(p_view, a2,b2,c2,d2);
    float sd_left = sdQuadSigned(p_view, a3,b3,c3,d3);
    float sd_right = sdQuadSigned(p_view, a4,b4,c4,d4);

    // Which polygon contains the point?
    int faceId = -1;
    if (sd_box < 0.0) { faceId = 0; }
    else if (sd_top < 0.0) { faceId = 1; }
    else if (sd_bottom < 0.0) { faceId = 2; }
    else if (sd_left < 0.0) { faceId = 3; }
    else if (sd_right < 0.0) { faceId = 4; }

    // 3. edge/wire distance
    float min_abs_dist = min(
        min(abs(sd_box), abs(sd_top)),
        min(min(abs(sd_bottom), abs(sd_left)), abs(sd_right))
    );

    // 4. GRADIENT LIGHTING PER FACE (mockup-accurate)
    half3 faceColor = half3(0.0, 0.0, 0.0);

    // Utilise le nouvel uniforme uFaceBrightness
    float brightness = uFaceBrightness;

    if (faceId == 0) {
        // FOND : Uniforme, bleu profond
        faceColor = uColorBox * brightness; // Utilise uColorBox

    } else if (faceId == 1) {
        // TOP WALL : Gradient vertical (clair en haut, sombre vers le fond)
        float distToInner = abs(p_view.y - uBoxHalfSize);
        float totalDist = abs(outerTL.y - uBoxHalfSize);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(uColorTopDark, uColorTopLight, t) * brightness; // Utilise uColorTop...

    } else if (faceId == 2) {
        // BOTTOM WALL : Gradient vertical (clair en bas, sombre vers le fond)
        float distToInner = abs(p_view.y + uBoxHalfSize);
        float totalDist = abs(outerBL.y + uBoxHalfSize);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(uColorBottomDark, uColorBottomLight, t) * brightness; // Utilise uColorBottom...

    } else if (faceId == 3) {
        // LEFT WALL : Gradient horizontal (clair à gauche, sombre vers le fond)
        float distToInner = abs(p_view.x + uBoxHalfSize);
        float totalDist = abs(outerTL.x + uBoxHalfSize);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(uColorLeftDark, uColorLeftLight, t) * brightness; // Utilise uColorLeft...

    } else if (faceId == 4) {
        // RIGHT WALL : Gradient horizontal (clair à droite, sombre vers le fond)
        float distToInner = abs(p_view.x - uBoxHalfSize);
        float totalDist = abs(outerTR.x - uBoxHalfSize);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(uColorRightDark, uColorRightLight, t) * brightness; // Utilise uColorRight...
    }

    // 5. AMBIENT OCCLUSION
    float ao = calculateAO(p_view, faceId, boxTL, boxTR, boxBR, boxBL, outerTL, outerTR, outerBR, outerBL);
    faceColor *= ao;

    float3 outColor = faceColor;

    // 6. NEON LINES (wireframe)
    float edgeWidth = max(uEdgeThickness, 0.0005);
    float lineCore = 1.0 - smoothstep(0.0, edgeWidth * 0.5, min_abs_dist);
    float glow = exp(-min_abs_dist * 30.0);
    float totalLine = clamp(lineCore * (0.6 + uRimIntensity * 0.8) + glow * 0.5, 0.0, 1.0);
    float coreMix = lineCore;

    // Utilise les uniforms uNeonLineColor et uHighlightColor
    float3 coreColor = mix(uNeonLineColor, uHighlightColor, coreMix);
    float3 neon = coreColor * totalLine;

    // 7. FINAL
    float3 color = outColor + neon;
    color = clamp(color, 0.0, 1.0);

    return half4(color, 1.0);
}
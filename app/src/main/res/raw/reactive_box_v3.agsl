// ReactiveBox V4 - "Ultra Realism" - Target 90-100% visual match
// Uniforms exposés pour tuning runtime
uniform float2 resolution;   // surface size (px)
uniform float2 uTilt;        // x=roll, y=pitch (radians or normalized)
uniform float  uTime;        // animation time
uniform float  uEdgeThickness; // 0.001..0.005 (ultra-fin)
uniform float  uRimIntensity;  // 0.5..1.5
uniform float  uSpecularPower; // 16..64
uniform float  uNoiseStrength; // 0..0.02

// Helpers
float2 aspectCorrect(float2 uv) {
    uv.x *= resolution.x / resolution.y;
    return uv;
}

// Enhanced pseudo-perspective with stronger depth
float2 pseudoPerspective(float2 uv, float2 vp, float depthTweak) {
    float2 toVP = vp - uv;
    float d = length(toVP);
    float factor = 1.0 / (1.0 + d * depthTweak);
    return mix(uv, vp, 1.0 - factor);
}

// Signed distance to rounded rect
float sdBoxRounded(float2 p, float2 b, float r) {
    float2 d = abs(p) - b;
    return length(max(d, 0.0)) - r + min(max(d.x, d.y), 0.0);
}

// Normal estimation with better z-bias
float3 estimateNormal(float2 uv, float2 box, float r) {
    float e = 0.0012;
    float cx = sdBoxRounded(uv + float2(e, 0), box, r);
    float nx = sdBoxRounded(uv - float2(e, 0), box, r);
    float cy = sdBoxRounded(uv + float2(0, e), box, r);
    float ny = sdBoxRounded(uv - float2(0, e), box, r);
    float dx = cx - nx;
    float dy = cy - ny;
    return normalize(float3(dx, dy, 0.7));
}

// 2D noise
float hash21(float2 p) {
    p = fract(p * float2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = fract(p);
    float a = hash21(i + float2(0.0, 0.0));
    float b = hash21(i + float2(1.0, 0.0));
    float c = hash21(i + float2(0.0, 1.0));
    float d = hash21(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Softer, more pastel color palette matching target
float3 faceColor(int face) {
    if (face == 0) return float3(0.18, 0.22, 0.42); // center - deeper blue
    if (face == 1) return float3(0.88, 0.76, 0.52); // top - soft gold
    if (face == 2) return float3(0.48, 0.88, 0.68); // bottom - mint green
    if (face == 3) return float3(0.72, 0.58, 0.82); // right - lavender
    return float3(0.52, 0.78, 0.88);                // left - sky blue
}

// Face detection
int detectFace(float2 uv, float2 box) {
    float ax = abs(uv.x);
    float ay = abs(uv.y);
    if (ax < box.x && ay < box.y) return 0;
    if (ay > ax) return uv.y > 0.0 ? 1 : 2;
    return uv.x > 0.0 ? 3 : 4;
}

// Smooth gradient falloff for face blending
float faceFalloff(float2 localUV, float power) {
    float2 dist = abs(localUV);
    float maxDist = max(dist.x, dist.y);
    return 1.0 - smoothstep(0.2, 1.0, maxDist);
}

half4 main(float2 fragCoord) {
    // Normalize coords with aspect correction
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;
    uv = aspectCorrect(uv);

    // Enhanced parameters for deeper 3D effect
    float depthAggression = 2.4;         // increased from 1.2
    float boxHalf = 0.76;                // slightly smaller for more depth
    float cornerRadius = 0.05;           // slightly larger rounding
    float edgeSoft = clamp(uEdgeThickness, 0.001, 0.005); // much finer

    // Vanishing point from tilt (convert radians to normalized range)
    // uTilt arrives in radians: Pitch [-π/2, π/2] and Roll [-π, π]
    float2 normalizedTilt = float2(
        uTilt.x / 1.57,  // Pitch: divide by π/2 (≈1.57) → [-1, 1]
        uTilt.y / 3.14   // Roll: divide by π (≈3.14) → [-1, 1]
    );
    float2 vp = normalizedTilt * 0.75;
    float2 pv = pseudoPerspective(uv, vp, depthAggression);

    // Stronger non-linear warp for depth
    float depthWarp = pow(length(pv) * 0.85, 1.6);
    pv *= (1.0 - 0.18 * depthWarp);

    // SDF and face detection
    float sdf = sdBoxRounded(pv, float2(boxHalf, boxHalf), cornerRadius);
    int face = detectFace(pv, float2(boxHalf, boxHalf));

    // Base color per face
    float3 base = faceColor(face);

    // Local UV per face for gradients
    float2 localUV = pv;
    if (face != 0) {
        if (face == 1) localUV = float2(pv.x, (pv.y - boxHalf));
        else if (face == 2) localUV = float2(pv.x, (pv.y + boxHalf));
        else if (face == 3) localUV = float2((pv.x - boxHalf), pv.y);
        else localUV = float2((pv.x + boxHalf), pv.y);
        localUV /= boxHalf;
    } else {
        localUV /= boxHalf;
    }

    // Smooth gradient from center to edges of each face
    float faceGrad = faceFalloff(localUV, 1.8);
    base = mix(base * 0.55, base, faceGrad);

    // Cross-face blending for seamless transitions
    float blendRadius = 0.12;
    float2 distToEdge = abs(abs(pv) - float2(boxHalf, boxHalf));
    float edgeBlend = smoothstep(0.0, blendRadius, min(distToEdge.x, distToEdge.y));

    // Normal estimation
    float3 n = estimateNormal(pv, float2(boxHalf, boxHalf), cornerRadius);

    // Softer, more ambient lighting (using normalized tilt)
    float3 lightDir = normalize(float3(-normalizedTilt.x * 1.0, -normalizedTilt.y * 1.0, 1.2));
    float3 view = float3(0.0, 0.0, 1.0);

    // Gentler diffuse
    float diff = max(dot(n, lightDir), 0.0);
    diff = pow(diff, 0.8); // soften the falloff

    // Subtle fresnel
    float fresnel = pow(1.0 - max(dot(n, view), 0.0), 3.0);

    // Much softer specular
    float3 halfV = normalize(lightDir + view);
    float specCore = pow(max(dot(n, halfV), 0.0), uSpecularPower) * 0.25;

    // Ultra-sharp, ultra-fine rim light
    float edge = smoothstep(edgeSoft * 1.5, 0.0, abs(sdf));
    float rim = pow(edge, 4.0) * uRimIntensity; // sharper with pow(4)

    // Enhanced ambient occlusion in corners and seams
    float distFromCenter = length(pv);
    float occlusion = smoothstep(0.4, 1.0, distFromCenter) * 0.7;
    float cornerOcclusion = smoothstep(-0.02, -0.08, sdf) * 0.5;
    float ao = clamp(1.0 - (occlusion + cornerOcclusion), 0.2, 1.0);

    // Very subtle noise
    float nseed = noise(pv * 15.0 + uTime * 0.015);
    float nval = (nseed - 0.5) * 2.0 * uNoiseStrength;

    // Cyan rim color matching target
    float3 rimColor = float3(0.5, 0.92, 1.0) * 1.3;

    // Shading composition - more matte appearance
    float3 baseShaded = base * (0.25 + 0.75 * diff * ao);

    // Subtle specular only on edges
    float3 specularColor = specCore * float3(0.9, 0.95, 1.0) * edgeBlend;

    // Strong cyan rim
    float3 rimGlow = rim * rimColor;

    // Ultra-fine inner edge line
    float innerLine = smoothstep(0.0015, 0.0, abs(sdf)) * 1.2;
    float3 lineColor = innerLine * float3(0.4, 0.85, 1.0);

    // Radial darkening from center (stronger)
    float centerFall = smoothstep(0.0, 0.75, distFromCenter);
    baseShaded *= (1.0 - 0.5 * centerFall);

    // Combine all elements
    float3 color = baseShaded + specularColor + rimGlow + lineColor;
    color += nval;

    // Smooth outer mask
    float outerMask = smoothstep(0.96, 0.92, sdBoxRounded(uv, float2(0.98, 0.98), 0.0));
    color = mix(float3(0.02, 0.02, 0.05), color, 1.0 - outerMask);

    // Subtle vignette
    float vign = smoothstep(1.5, 0.2, length(uv) * 1.1);
    color *= mix(1.0, 0.88, vign * 0.5);

    // Final color grading for softer look
    color = pow(color, float3(0.92, 0.92, 0.92));

    // Slight desaturation for more realistic matte finish
    float luma = dot(color, float3(0.299, 0.587, 0.114));
    color = mix(float3(luma), color, 0.92);

    return half4(color, 1.0);
}
// reactive_box_simple_lighting.agsl
uniform float2 resolution;
uniform float2 uTilt;
uniform float uTime;
uniform float uEdgeThickness;
uniform float uRimIntensity;
uniform float uSpecularPower;
uniform float uNoiseStrength;

// Constantes
const float BOX_HALF_SIZE = 0.6;
const float WALL_LIMIT = 1.0;
const half3 NEON_LINE_COLOR = half3(0.0, 1.0, 1.0); // cyan
const half3 HIGHLIGHT_COLOR = half3(0.9, 0.95, 1.0);

// Couleurs de face
const half3 COLOR_BOX = half3(0.2, 0.15, 0.4);      // Bleu foncé (fond)
const half3 COLOR_TOP = half3(1.0, 0.5, 0.1);       // Orange
const half3 COLOR_BOTTOM = half3(0.2, 0.8, 0.5);    // Vert/cyan
const half3 COLOR_LEFT = half3(0.3, 0.8, 0.9);      // Cyan clair
const half3 COLOR_RIGHT = half3(0.9, 0.4, 0.8);     // Rose


// ----------------- HELPERS -----------------
float2 aspectCorrect(float2 uv) {
    uv.x *= resolution.x / resolution.y;
    return uv;
}

float2 normalizeTilt(float2 tilt) {
    float maxOffset = WALL_LIMIT - BOX_HALF_SIZE;
    return clamp(tilt, -maxOffset, maxOffset);
}

// distance to segment (unsigned)
float sdSegment(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float denom = dot(ba, ba);
    if (denom <= 1e-8) return length(pa);
    float h = clamp(dot(pa, ba) / denom, 0.0, 1.0);
    return length(pa - ba * h);
}

// Signed distance to convex quad (negative inside)
float sdQuadSigned(float2 p, float2 a, float2 b, float2 c, float2 d) {
    float d0 = sdSegment(p, a, b);
    float d1 = sdSegment(p, b, c);
    float d2 = sdSegment(p, c, d);
    float d3 = sdSegment(p, d, a);
    float mind = min(min(d0, d1), min(d2, d3));

    float2 ab = b - a;
    float2 bc = c - b;
    float2 cd = d - c;
    float2 da = a - d;

    float c0 = ab.x * (p.y - a.y) - ab.y * (p.x - a.x);
    float c1 = bc.x * (p.y - b.y) - bc.y * (p.x - b.x);
    float c2 = cd.x * (p.y - c.y) - cd.y * (p.x - c.x);
    float c3 = da.x * (p.y - d.y) - da.y * (p.x - d.x);

    bool allPos = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0);
    bool allNeg = (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);

    return (allPos || allNeg) ? -mind : mind;
}

// Signed area (shoelace) of quad (a,b,c,d). Positive => CCW
float quadSignedArea(float2 a, float2 b, float2 c, float2 d) {
    float s = 0.0;
    s += a.x * b.y - b.x * a.y;
    s += b.x * c.y - c.x * b.y;
    s += c.x * d.y - d.x * c.y;
    s += d.x * a.y - a.x * d.y;
    return 0.5 * s;
}

// swap helper
void swap(inout float2 x, inout float2 y) {
    float2 t = x; x = y; y = t;
}

// ----------------- MAIN -----------------
half4 main(float2 fragCoord) {
    // 1. uv / view space
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;
    uv.y *= -1.0;

    float2 nTilt = normalizeTilt(uTilt);
    float2 p_view = aspectCorrect(uv + nTilt);

    // outer corners (aspect corrected then tilt offset)
    float2 nTilt_corrected = aspectCorrect(nTilt);
    float2 outerTL = aspectCorrect(float2(-WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerTR = aspectCorrect(float2( WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerBR = aspectCorrect(float2( WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;
    float2 outerBL = aspectCorrect(float2(-WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;

    // box corners (center)
    float2 boxTL = float2(-BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxTR = float2( BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxBR = float2( BOX_HALF_SIZE, -BOX_HALF_SIZE);
    float2 boxBL = float2(-BOX_HALF_SIZE, -BOX_HALF_SIZE);

    // --- build quads with consistent winding (CCW) ---
    float2 a0 = boxTL, b0 = boxTR, c0 = boxBR, d0 = boxBL;
    if (quadSignedArea(a0,b0,c0,d0) < 0.0) { swap(b0, d0); }

    float2 a1 = boxTL, b1 = boxTR, c1 = outerTR, d1 = outerTL;
    if (quadSignedArea(a1,b1,c1,d1) < 0.0) { swap(b1, d1); }

    float2 a2 = boxBR, b2 = boxBL, c2 = outerBL, d2 = outerBR;
    if (quadSignedArea(a2,b2,c2,d2) < 0.0) { swap(b2, d2); }

    float2 a3 = outerTL, b3 = boxTL, c3 = boxBL, d3 = outerBL;
    if (quadSignedArea(a3,b3,c3,d3) < 0.0) { swap(b3, d3); }

    float2 a4 = boxTR, b4 = outerTR, c4 = outerBR, d4 = boxBR;
    if (quadSignedArea(a4,b4,c4,d4) < 0.0) { swap(b4, d4); }

    // 2. signed distances
    float sd_box = sdQuadSigned(p_view, a0,b0,c0,d0);
    float sd_top = sdQuadSigned(p_view, a1,b1,c1,d1);
    float sd_bottom = sdQuadSigned(p_view, a2,b2,c2,d2);
    float sd_left = sdQuadSigned(p_view, a3,b3,c3,d3);
    float sd_right = sdQuadSigned(p_view, a4,b4,c4,d4);

    // Which polygon contains the point?
    int faceId = -1;
    if (sd_box < 0.0) { faceId = 0; }
    else if (sd_top < 0.0) { faceId = 1; }
    else if (sd_bottom < 0.0) { faceId = 2; }
    else if (sd_left < 0.0) { faceId = 3; }
    else if (sd_right < 0.0) { faceId = 4; }

    // 3. edge/wire distance
    float min_abs_dist = min(
        min(abs(sd_box), abs(sd_top)),
        min(min(abs(sd_bottom), abs(sd_left)), abs(sd_right))
    );

    // 4. LIGHTING SIMPLE ET STABLE
    // Base color par face
    half3 baseColor = half3(0.0, 0.0, 0.0);
    if (faceId == 0) baseColor = COLOR_BOX;
    else if (faceId == 1) baseColor = COLOR_TOP;
    else if (faceId == 2) baseColor = COLOR_BOTTOM;
    else if (faceId == 3) baseColor = COLOR_LEFT;
    else if (faceId == 4) baseColor = COLOR_RIGHT;

    // Lighting simple basé sur la position (pas de normales complexes)
    float2 lightDir = normalize(float2(0.7, 0.5));
    float posLight = dot(normalize(p_view + float2(0.001, 0.001)), lightDir) * 0.5 + 0.5; // 0 à 1

    // Facteur de lighting par face (statique, donne la profondeur)
    float faceLightFactor = 1.0;
    if (faceId == 0) faceLightFactor = 0.1;      // Fond un peu sombre
    else if (faceId == 1) faceLightFactor = 0.2;  // Top lumineux
    else if (faceId == 2) faceLightFactor = 0.2;  // Bottom moyen
    else if (faceId == 3) faceLightFactor = 0.2;  // Left
    else if (faceId == 4) faceLightFactor = 0.2; // Right

    // Lighting final : base + variation subtile basée sur la position
    float lighting = faceLightFactor + posLight * 0.2;
    half3 faceColor = baseColor * lighting;

    float3 outColor = faceColor;

    // 5. NEON LINES (wireframe)
    float edgeWidth = max(uEdgeThickness, 0.0005);
    float lineCore = 1.0 - smoothstep(0.0, edgeWidth * 0.5, min_abs_dist);
    float glow = exp(-min_abs_dist * 30.0);
    float totalLine = clamp(lineCore * (0.6 + uRimIntensity * 0.8) + glow * 0.5, 0.0, 1.0);
    float coreMix = lineCore;
    float3 coreColor = mix(NEON_LINE_COLOR, HIGHLIGHT_COLOR, coreMix);
    float3 neon = coreColor * totalLine;

    // 6. FINAL
    float3 color = outColor + neon;
    color = clamp(color, 0.0, 1.0);

    return half4(color, 1.0);
}
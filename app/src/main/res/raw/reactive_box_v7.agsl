// reactive_box_full_fixed.agsl
uniform float2 resolution;
uniform float2 uTilt;
uniform float uTime;
uniform float uEdgeThickness;
uniform float uRimIntensity;
uniform float uSpecularPower;
uniform float uNoiseStrength;

// Constantes
const float BOX_HALF_SIZE = 0.6;
const float WALL_LIMIT = 1.0;
const float EPSILON = 0.008;
const half3 NEON_LINE_COLOR = half3(0.0, 1.0, 1.0); // cyan
const half3 FACE_BASE_COLOR = half3(1.0, 0.25, 1.0);
const half3 HIGHLIGHT_COLOR = half3(0.9, 0.95, 1.0);


// ----------------- HELPERS -----------------
float2 aspectCorrect(float2 uv) {
    uv.x *= resolution.x / resolution.y;
    return uv;
}

float2 normalizeTilt(float2 tilt) {
    float maxOffset = WALL_LIMIT - BOX_HALF_SIZE;
    return clamp(tilt, -maxOffset, maxOffset);
}

// distance to segment (unsigned)
float sdSegment(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float denom = dot(ba, ba);
    if (denom <= 1e-8) return length(pa); // degenerate edge -> distance to a
    float h = clamp(dot(pa, ba) / denom, 0.0, 1.0);
    return length(pa - ba * h);
}

// Signed distance to convex quad (negative inside)
float sdQuadSigned(float2 p, float2 a, float2 b, float2 c, float2 d) {
    float d0 = sdSegment(p, a, b);
    float d1 = sdSegment(p, b, c);
    float d2 = sdSegment(p, c, d);
    float d3 = sdSegment(p, d, a);
    float mind = min(min(d0, d1), min(d2, d3));

    float2 ab = b - a;
    float2 bc = c - b;
    float2 cd = d - c;
    float2 da = a - d;

    float c0 = ab.x * (p.y - a.y) - ab.y * (p.x - a.x);
    float c1 = bc.x * (p.y - b.y) - bc.y * (p.x - b.x);
    float c2 = cd.x * (p.y - c.y) - cd.y * (p.x - c.x);
    float c3 = da.x * (p.y - d.y) - da.y * (p.x - d.x);

    bool allPos = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0);
    bool allNeg = (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);

    return (allPos || allNeg) ? -mind : mind;
}

// Compute outward-ish normal for a quad by averaging edge normals (2D)
float2 quadNormal(float2 a, float2 b, float2 c, float2 d) {
    float2 e0 = b - a;
    float2 e1 = c - b;
    float2 e2 = d - c;
    float2 e3 = a - d;
    // normals (perp clockwise)
    float2 n0 = e0.y == 0.0 && e0.x == 0.0 ? float2(0.0, 1.0) : normalize(float2(-e0.y, e0.x));
    float2 n1 = e1.y == 0.0 && e1.x == 0.0 ? float2(0.0, 1.0) : normalize(float2(-e1.y, e1.x));
    float2 n2 = e2.y == 0.0 && e2.x == 0.0 ? float2(0.0, 1.0) : normalize(float2(-e2.y, e2.x));
    float2 n3 = e3.y == 0.0 && e3.x == 0.0 ? float2(0.0, 1.0) : normalize(float2(-e3.y, e3.x));
    float2 navg = n0 + n1 + n2 + n3;
    float len = length(navg);
    return len > 1e-6 ? navg / len : float2(0.0, 1.0);
}

// Signed area (shoelace) of quad (a,b,c,d). Positive => CCW
float quadSignedArea(float2 a, float2 b, float2 c, float2 d) {
    float s = 0.0;
    s += a.x * b.y - b.x * a.y;
    s += b.x * c.y - c.x * b.y;
    s += c.x * d.y - d.x * c.y;
    s += d.x * a.y - a.x * d.y;
    return 0.5 * s;
}

// cheap hash noise
float hash21(float2 p) {
    p = fract(p * float2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

// swap helper
void swap(inout float2 x, inout float2 y) {
    float2 t = x; x = y; y = t;
}

// ----------------- MAIN -----------------
half4 main(float2 fragCoord) {
    // 1. uv / view space
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;
    uv.y *= -1.0;

    float2 nTilt = normalizeTilt(uTilt);
    float2 p_view = aspectCorrect(uv + nTilt);

    // outer corners (aspect corrected then tilt offset)
    float2 nTilt_corrected = aspectCorrect(nTilt);
    float2 outerTL = aspectCorrect(float2(-WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerTR = aspectCorrect(float2( WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerBR = aspectCorrect(float2( WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;
    float2 outerBL = aspectCorrect(float2(-WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;

    // box corners (center)
    float2 boxTL = float2(-BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxTR = float2( BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxBR = float2( BOX_HALF_SIZE, -BOX_HALF_SIZE);
    float2 boxBL = float2(-BOX_HALF_SIZE, -BOX_HALF_SIZE);

    // --- build quads with consistent winding (CCW) ---
    // Box: TL, TR, BR, BL (should be CCW)
    float2 a0 = boxTL, b0 = boxTR, c0 = boxBR, d0 = boxBL;
    if (quadSignedArea(a0,b0,c0,d0) < 0.0) { swap(b0, d0); } // ensure CCW

    // Top: boxTL, boxTR, outerTR, outerTL
    float2 a1 = boxTL, b1 = boxTR, c1 = outerTR, d1 = outerTL;
    if (quadSignedArea(a1,b1,c1,d1) < 0.0) { swap(b1, d1); }

    // Bottom: boxBR, boxBL, outerBL, outerBR  (keep CCW)
    float2 a2 = boxBR, b2 = boxBL, c2 = outerBL, d2 = outerBR;
    if (quadSignedArea(a2,b2,c2,d2) < 0.0) { swap(b2, d2); }

    // Left: outerTL, boxTL, boxBL, outerBL
    float2 a3 = outerTL, b3 = boxTL, c3 = boxBL, d3 = outerBL;
    if (quadSignedArea(a3,b3,c3,d3) < 0.0) { swap(b3, d3); }

    // Right: boxTR, outerTR, outerBR, boxBR
    float2 a4 = boxTR, b4 = outerTR, c4 = outerBR, d4 = boxBR;
    if (quadSignedArea(a4,b4,c4,d4) < 0.0) { swap(b4, d4); }

    // 2. signed distances
    float sd_box = sdQuadSigned(p_view, a0,b0,c0,d0);
    float sd_top = sdQuadSigned(p_view, a1,b1,c1,d1);
    float sd_bottom = sdQuadSigned(p_view, a2,b2,c2,d2);
    float sd_left = sdQuadSigned(p_view, a3,b3,c3,d3);
    float sd_right = sdQuadSigned(p_view, a4,b4,c4,d4);

    // Which polygon contains the point? prefer the innermost (box) then others.
    int faceId = -1;
    float faceSD = 1e6;
    if (sd_box < 0.0) { faceId = 0; faceSD = sd_box; }
    else if (sd_top < 0.0) { faceId = 1; faceSD = sd_top; }
    else if (sd_bottom < 0.0) { faceId = 2; faceSD = sd_bottom; }
    else if (sd_left < 0.0) { faceId = 3; faceSD = sd_left; }
    else if (sd_right < 0.0) { faceId = 4; faceSD = sd_right; }

    float signed_min = min(min(sd_box, sd_top), min(min(sd_bottom, sd_left), sd_right));

    // 3. edge/wire distance (absolute to edges across all quads)
    float min_abs_dist = min(
        min(abs(sd_box), abs(sd_top)),
        min(min(abs(sd_bottom), abs(sd_left)), abs(sd_right))
    );

    // 4. normals (use the possibly re-wound quads)
    float2 n_box = quadNormal(a0,b0,c0,d0);
    float2 n_top = quadNormal(a1,b1,c1,d1);
    float2 n_bottom = quadNormal(a2,b2,c2,d2);
    float2 n_left = quadNormal(a3,b3,c3,d3);
    float2 n_right = quadNormal(a4,b4,c4,d4);

    float3 faceColor = FACE_BASE_COLOR;
    float3 outColor = half3(0.0, 0.0, 0.0);

    // light/view
    float2 lightDir = normalize(float2(0.7, 0.5));
    float2 viewDir = normalize(float2(0.0, 0.0) - p_view);

    // pick normal
    float2 normal2 = float2(0.0, 0.0);
    if (faceId == 0) normal2 = normalize(n_box - nTilt * 0.1);
    else if (faceId == 1) normal2 = n_top;
    else if (faceId == 2) normal2 = n_bottom;
    else if (faceId == 3) normal2 = n_left;
    else if (faceId == 4) normal2 = n_right;
    else {
        // nearest face normal
        float a = abs(sd_box);
        float b = abs(sd_top);
        float c = abs(sd_bottom);
        float d = abs(sd_left);
        float e = abs(sd_right);
        float m = a; normal2 = n_box;
        if (b < m) { m = b; normal2 = n_top; }
        if (c < m) { m = c; normal2 = n_bottom; }
        if (d < m) { m = d; normal2 = n_left; }
        if (e < m) { m = e; normal2 = n_right; }
    }
    normal2 = normalize(normal2 + 1e-6);

    float NdotL = clamp(dot(normal2, lightDir), 0.0, 1.0);
    float lambert = NdotL;
    float rim = pow(clamp(1.0 - max(dot(normal2, viewDir), 0.0), 0.0, 1.0), 1.5) * uRimIntensity;
    float2 refl = normalize(2.0 * dot(normal2, lightDir) * normal2 - lightDir);
    float spec = pow(max(dot(refl, viewDir), 0.0), max(1.0, uSpecularPower));
    float noise = (hash21(p_view * 37.0 + uTime * 0.1) - 0.5) * uNoiseStrength;
    float faceLighting = clamp(0.15 + lambert * 0.35 + rim * 0.25 + spec * 0.5 + noise, 0.0, 1.0);
    faceColor = FACE_BASE_COLOR * faceLighting;

    float fillAlpha = 0.99; // comme demandÃ©
    outColor = faceColor * fillAlpha;



    // wire / neon
    float edgeWidth = max(uEdgeThickness, 0.0005);
    float lineCore = 1.0 - smoothstep(0.0, edgeWidth * 0.5, min_abs_dist);
    float glow = exp(-min_abs_dist * 30.0);
    float totalLine = clamp(lineCore * (0.6 + uRimIntensity * 0.8) + glow * 0.5, 0.0, 1.0);
    float coreMix = lineCore;
    float3 coreColor = mix(NEON_LINE_COLOR, HIGHLIGHT_COLOR, coreMix);
    float3 neon = coreColor * totalLine;

    float3 color = outColor + neon;
    color = clamp(color, 0.0, 1.0);

    return half4(color, 1.0);
}

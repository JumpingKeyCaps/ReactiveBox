// reactive_box_with_ao.agsl
uniform float2 resolution;
uniform float2 uTilt;
uniform float uTime;
uniform float uEdgeThickness;
uniform float uRimIntensity;
uniform float uSpecularPower;
uniform float uNoiseStrength;

// Constantes
const float BOX_HALF_SIZE = 0.6;
const float WALL_LIMIT = 1.0;
const half3 NEON_LINE_COLOR = half3(0.0, 1.0, 1.0); // cyan
const half3 HIGHLIGHT_COLOR = half3(0.9, 0.95, 1.0);

// RÉGLAGE FACILE : Luminosité globale des faces (0.0 = noir, 1.0 = full)
const float FACE_BRIGHTNESS = 0.7; // ← Ajuste cette valeur !

// AMBIENT OCCLUSION
const float AO_STRENGTH = 0.3;     // Intensité de l'AO (0.0 = off, 1.0 = max)
const float AO_RADIUS = 0.3;      // Rayon d'influence de l'AO

// Couleurs de face (base colors from mockup - remises à saturation normale)
const half3 COLOR_BOX = half3(0.15, 0.2, 0.35);        // Bleu profond uniforme
const half3 COLOR_TOP_LIGHT = half3(1.0, 0.65, 0.3);   // Orange clair (extérieur)
const half3 COLOR_TOP_DARK = half3(0.6, 0.35, 0.15);   // Orange sombre (intérieur)
const half3 COLOR_BOTTOM_LIGHT = half3(0.3, 0.9, 0.5); // Vert clair (extérieur)
const half3 COLOR_BOTTOM_DARK = half3(0.1, 0.4, 0.25); // Vert sombre (intérieur)
const half3 COLOR_LEFT_LIGHT = half3(0.4, 0.95, 1.0);  // Cyan clair (extérieur)
const half3 COLOR_LEFT_DARK = half3(0.15, 0.45, 0.55); // Cyan sombre (intérieur)
const half3 COLOR_RIGHT_LIGHT = half3(1.0, 0.5, 0.9);  // Rose clair (extérieur)
const half3 COLOR_RIGHT_DARK = half3(0.5, 0.2, 0.45);  // Rose sombre (intérieur)


// ----------------- HELPERS -----------------
float2 aspectCorrect(float2 uv) {
    uv.x *= resolution.x / resolution.y;
    return uv;
}

float2 normalizeTilt(float2 tilt) {
    float maxOffset = WALL_LIMIT - BOX_HALF_SIZE;
    return clamp(tilt, -maxOffset, maxOffset);
}

// distance to segment (unsigned)
float sdSegment(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float denom = dot(ba, ba);
    if (denom <= 1e-8) return length(pa);
    float h = clamp(dot(pa, ba) / denom, 0.0, 1.0);
    return length(pa - ba * h);
}

// Signed distance to convex quad (negative inside)
float sdQuadSigned(float2 p, float2 a, float2 b, float2 c, float2 d) {
    float d0 = sdSegment(p, a, b);
    float d1 = sdSegment(p, b, c);
    float d2 = sdSegment(p, c, d);
    float d3 = sdSegment(p, d, a);
    float mind = min(min(d0, d1), min(d2, d3));

    float2 ab = b - a;
    float2 bc = c - b;
    float2 cd = d - c;
    float2 da = a - d;

    float c0 = ab.x * (p.y - a.y) - ab.y * (p.x - a.x);
    float c1 = bc.x * (p.y - b.y) - bc.y * (p.x - b.x);
    float c2 = cd.x * (p.y - c.y) - cd.y * (p.x - c.x);
    float c3 = da.x * (p.y - d.y) - da.y * (p.x - d.x);

    bool allPos = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0);
    bool allNeg = (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);

    return (allPos || allNeg) ? -mind : mind;
}

// Signed area (shoelace) of quad (a,b,c,d). Positive => CCW
float quadSignedArea(float2 a, float2 b, float2 c, float2 d) {
    float s = 0.0;
    s += a.x * b.y - b.x * a.y;
    s += b.x * c.y - c.x * b.y;
    s += c.x * d.y - d.x * c.y;
    s += d.x * a.y - a.x * d.y;
    return 0.5 * s;
}

// swap helper
void swap(inout float2 x, inout float2 y) {
    float2 t = x; x = y; y = t;
}

// Calcul de l'Ambient Occlusion basé sur la distance aux arêtes (avec diagonales)
float calculateAO(float2 p, int faceId,
                  float2 boxTL, float2 boxTR, float2 boxBR, float2 boxBL,
                  float2 outerTL, float2 outerTR, float2 outerBR, float2 outerBL) {

    float ao = 1.0; // Pas d'occlusion par défaut

    if (faceId == 0) {
        // FOND : AO aux 4 bords
        float distToEdges = min(
            min(abs(p.x - BOX_HALF_SIZE), abs(p.x + BOX_HALF_SIZE)),
            min(abs(p.y - BOX_HALF_SIZE), abs(p.y + BOX_HALF_SIZE))
        );
        ao = smoothstep(0.0, AO_RADIUS, distToEdges);

    } else if (faceId == 1) {
        // TOP WALL : AO le long de l'arête intérieure + diagonales
        float distToBottom = abs(p.y - BOX_HALF_SIZE);
        ao = smoothstep(0.0, AO_RADIUS, distToBottom);

        // AO le long des diagonales gauche et droite
        float distToDiagL = sdSegment(p, boxTL, outerTL);
        float distToDiagR = sdSegment(p, boxTR, outerTR);
        float diagAO = smoothstep(0.0, AO_RADIUS * 0.6, min(distToDiagL, distToDiagR));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 2) {
        // BOTTOM WALL : AO le long de l'arête intérieure + diagonales
        float distToTop = abs(p.y + BOX_HALF_SIZE);
        ao = smoothstep(0.0, AO_RADIUS, distToTop);

        // AO le long des diagonales
        float distToDiagL = sdSegment(p, boxBL, outerBL);
        float distToDiagR = sdSegment(p, boxBR, outerBR);
        float diagAO = smoothstep(0.0, AO_RADIUS * 0.6, min(distToDiagL, distToDiagR));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 3) {
        // LEFT WALL : AO le long de l'arête intérieure + diagonales
        float distToRight = abs(p.x + BOX_HALF_SIZE);
        ao = smoothstep(0.0, AO_RADIUS, distToRight);

        // AO le long des diagonales haut et bas
        float distToDiagT = sdSegment(p, boxTL, outerTL);
        float distToDiagB = sdSegment(p, boxBL, outerBL);
        float diagAO = smoothstep(0.0, AO_RADIUS * 0.6, min(distToDiagT, distToDiagB));
        ao *= mix(0.4, 1.0, diagAO);

    } else if (faceId == 4) {
        // RIGHT WALL : AO le long de l'arête intérieure + diagonales
        float distToLeft = abs(p.x - BOX_HALF_SIZE);
        ao = smoothstep(0.0, AO_RADIUS, distToLeft);

        // AO le long des diagonales haut et bas
        float distToDiagT = sdSegment(p, boxTR, outerTR);
        float distToDiagB = sdSegment(p, boxBR, outerBR);
        float diagAO = smoothstep(0.0, AO_RADIUS * 0.6, min(distToDiagT, distToDiagB));
        ao *= mix(0.4, 1.0, diagAO);
    }

    // Mix avec la force de l'AO
    return mix(1.0, ao, AO_STRENGTH);
}

// ----------------- MAIN -----------------
half4 main(float2 fragCoord) {
    // 1. uv / view space
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;
    uv.y *= -1.0;

    float2 nTilt = normalizeTilt(uTilt);
    float2 p_view = aspectCorrect(uv + nTilt);

    // outer corners (aspect corrected then tilt offset)
    float2 nTilt_corrected = aspectCorrect(nTilt);
    float2 outerTL = aspectCorrect(float2(-WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerTR = aspectCorrect(float2( WALL_LIMIT,  WALL_LIMIT)) + nTilt_corrected;
    float2 outerBR = aspectCorrect(float2( WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;
    float2 outerBL = aspectCorrect(float2(-WALL_LIMIT, -WALL_LIMIT)) + nTilt_corrected;

    // box corners (center)
    float2 boxTL = float2(-BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxTR = float2( BOX_HALF_SIZE,  BOX_HALF_SIZE);
    float2 boxBR = float2( BOX_HALF_SIZE, -BOX_HALF_SIZE);
    float2 boxBL = float2(-BOX_HALF_SIZE, -BOX_HALF_SIZE);

    // --- build quads with consistent winding (CCW) ---
    float2 a0 = boxTL, b0 = boxTR, c0 = boxBR, d0 = boxBL;
    if (quadSignedArea(a0,b0,c0,d0) < 0.0) { swap(b0, d0); }

    float2 a1 = boxTL, b1 = boxTR, c1 = outerTR, d1 = outerTL;
    if (quadSignedArea(a1,b1,c1,d1) < 0.0) { swap(b1, d1); }

    float2 a2 = boxBR, b2 = boxBL, c2 = outerBL, d2 = outerBR;
    if (quadSignedArea(a2,b2,c2,d2) < 0.0) { swap(b2, d2); }

    float2 a3 = outerTL, b3 = boxTL, c3 = boxBL, d3 = outerBL;
    if (quadSignedArea(a3,b3,c3,d3) < 0.0) { swap(b3, d3); }

    float2 a4 = boxTR, b4 = outerTR, c4 = outerBR, d4 = boxBR;
    if (quadSignedArea(a4,b4,c4,d4) < 0.0) { swap(b4, d4); }

    // 2. signed distances
    float sd_box = sdQuadSigned(p_view, a0,b0,c0,d0);
    float sd_top = sdQuadSigned(p_view, a1,b1,c1,d1);
    float sd_bottom = sdQuadSigned(p_view, a2,b2,c2,d2);
    float sd_left = sdQuadSigned(p_view, a3,b3,c3,d3);
    float sd_right = sdQuadSigned(p_view, a4,b4,c4,d4);

    // Which polygon contains the point?
    int faceId = -1;
    if (sd_box < 0.0) { faceId = 0; }
    else if (sd_top < 0.0) { faceId = 1; }
    else if (sd_bottom < 0.0) { faceId = 2; }
    else if (sd_left < 0.0) { faceId = 3; }
    else if (sd_right < 0.0) { faceId = 4; }

    // 3. edge/wire distance
    float min_abs_dist = min(
        min(abs(sd_box), abs(sd_top)),
        min(min(abs(sd_bottom), abs(sd_left)), abs(sd_right))
    );

    // 4. GRADIENT LIGHTING PER FACE (mockup-accurate)
    half3 faceColor = half3(0.0, 0.0, 0.0);

    if (faceId == 0) {
        // FOND : Uniforme, bleu profond
        faceColor = COLOR_BOX * FACE_BRIGHTNESS;

    } else if (faceId == 1) {
        // TOP WALL : Gradient vertical (clair en haut, sombre vers le fond)
        float distToInner = abs(p_view.y - BOX_HALF_SIZE);
        float distToOuter = abs(p_view.y - outerTL.y);
        float totalDist = abs(outerTL.y - BOX_HALF_SIZE);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(COLOR_TOP_DARK, COLOR_TOP_LIGHT, t) * FACE_BRIGHTNESS;

    } else if (faceId == 2) {
        // BOTTOM WALL : Gradient vertical (clair en bas, sombre vers le fond)
        float distToInner = abs(p_view.y + BOX_HALF_SIZE);
        float distToOuter = abs(p_view.y - outerBL.y);
        float totalDist = abs(outerBL.y + BOX_HALF_SIZE);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(COLOR_BOTTOM_DARK, COLOR_BOTTOM_LIGHT, t) * FACE_BRIGHTNESS;

    } else if (faceId == 3) {
        // LEFT WALL : Gradient horizontal (clair à gauche, sombre vers le fond)
        float distToInner = abs(p_view.x + BOX_HALF_SIZE);
        float distToOuter = abs(p_view.x - outerTL.x);
        float totalDist = abs(outerTL.x + BOX_HALF_SIZE);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(COLOR_LEFT_DARK, COLOR_LEFT_LIGHT, t) * FACE_BRIGHTNESS;

    } else if (faceId == 4) {
        // RIGHT WALL : Gradient horizontal (clair à droite, sombre vers le fond)
        float distToInner = abs(p_view.x - BOX_HALF_SIZE);
        float distToOuter = abs(p_view.x - outerTR.x);
        float totalDist = abs(outerTR.x - BOX_HALF_SIZE);
        float t = clamp(distToInner / totalDist, 0.0, 1.0);
        t = smoothstep(0.0, 1.0, t);
        faceColor = mix(COLOR_RIGHT_DARK, COLOR_RIGHT_LIGHT, t) * FACE_BRIGHTNESS;
    }

    // 5. AMBIENT OCCLUSION
    float ao = calculateAO(p_view, faceId, boxTL, boxTR, boxBR, boxBL, outerTL, outerTR, outerBR, outerBL);
    faceColor *= ao;

    float3 outColor = faceColor;

    // 6. NEON LINES (wireframe)
    float edgeWidth = max(uEdgeThickness, 0.0005);
    float lineCore = 1.0 - smoothstep(0.0, edgeWidth * 0.5, min_abs_dist);
    float glow = exp(-min_abs_dist * 30.0);
    float totalLine = clamp(lineCore * (0.6 + uRimIntensity * 0.8) + glow * 0.5, 0.0, 1.0);
    float coreMix = lineCore;
    float3 coreColor = mix(NEON_LINE_COLOR, HIGHLIGHT_COLOR, coreMix);
    float3 neon = coreColor * totalLine;

    // 7. FINAL
    float3 color = outColor + neon;
    color = clamp(color, 0.0, 1.0);

    return half4(color, 1.0);
}